# PAA 2024 - Marcio Costa Santos <marciocs@dc.ufmg.br> & Olga NIkolaevna Goussevskaia

livro do cormen e do udi manber

## Aula 1 - 25/09/24

Primeira aula √© pra explicar

- An√°lise e complexidade de algoritmos
- Algoritmos em grafos
- Projetos e Design de algoritmos
- Complexidade de problemas

Os dois primeiros √© dele. As duas √∫ltimas √© com a Olga.

Cada um dos m√≥dulos vale 25 pontos. O primeiro m√≥dulo s√≥ tem uma prova que vale 25. Nos outros ter√° uma prova mais uma atividade, podendo ser uma lista de exerc√≠cios ou um trabalho pr√°tico. Cada professor define de que forma distribui os 25 pontos entre prova e atividade.

Muito provavelmente pra ele ser√° 20 pra prova e 5 pra atividade/lista. Geralmente a Olga faz (20 e 5), e (15, 10)

V√¢o postar o cronograma de PAA no Moodle.

Algumas das avalia√ß√µes s√£o tamb√©m pelo Moodle

Ele geralmente usa slide e tamb√©m escreve muito no quadro. Algumas coisas como algoritmos e desenhos ele prefere ter no slide.

Os slides e as listas ele disponibiliza no Moodle, mesmo que ele n√£o fa√ßa atividades s√≥ de exerc√≠cios. Ele deve fazer duas aulas assim antes de cada uma das provas dos dois primeiros m√≥dulos. Por√©m, tente resolver todos os exerc√≠cios antes das aulas.

Pretende enviar todo o material do m√≥dulo de uma s√≥ vez.

Ele segue um livro e a Olga, outro. Ele gosta de seguir o Cormen "de cabo a rabo".

Ele vai indicar quais cap√≠tulos correspondem √†quela aula.

### Sobre o m√≥dulo

Ela n√£o √© uma disciplina pra aprender a programar, nem √© das mais f√°ceis de teoria.

Exemplo que ele vai fingir que vc sabe: PA, PG, Logaritmo; Estruturas de controle em programa√ß√£o; Estruturas de dados b√°sicos (filha, pilha, √°rvore, heap);

A disciplina √© de An√°lise e constru√ß√£o de algoritmo. A ideia do curso √© que voc√™ j√° entende o b√°sico e vai partir da√≠.

O professor Coutinho criou um material de estudo que √© o "Pr√©-PAA" que tem uma sequ√™ncia de materiais para estudo pr√≥prio. Se n√£o souber de algo, pare e tente resolver.

√â importante seguir o cronograma e fazer isso o mais r√°pido poss√≠vel.

As aulas v√£o come√ßar b√°sicas e elas tendem a se tornar muito complicadas.

Exemplo: Aula 1 √© o b√°sico de grafos. Aula 2 j√° seria a nota√ß√£o matem√°tica para o que foi dado na aula 1.

Ele deve usar bastante transforma√ß√£o de logaritmo.

- Que linguagem de programa√ß√£o √© usada em PAA?
  - Nenhuma. O que ele vai mostrar s√£o algoritmos. Exemplos: `while (deu certo)`, `Inclui V NaLista L`, `R = folhas da √°rvore T`.
  - No in√≠cio ele deve tentar esquematizar mais a parte da estrutura dos dados, mas com o tempo vai se tornar cada vez mais abstrato.

Especialmente em algoritmos recursivos ele vai explicar como funciona o algoritmo, principalmente na ideia, mas faltando alguns passos. Exemplo: ignorando todos os corner-cases e focar na ideia que √© principal.

Python, Java, C ou C++. Ele √© muito fanboy de Julia kkkkkkkkkkkkkkkkkkkkkk

O trabalho provavelmente vai envolver alguma coisa de programa√ß√£o.

- Ele mais se importa que a ideia do algoritmo esteja certa. N√£o importa muito os pormenores. Aqueles √∫ltimos detalhes:
  - Divide em grupos de cinco
    - E se n√£o for m√∫ltiplo?
  - Divide na metade
    - E se for √≠mpar?

A primeira parte da disciplina n√£o √© criar algoritmos, apenas analis√°-los.

Nessa primeira parte √© aquela an√°lise de Big-O para definir a quantidade de passos que o algoritmo executa.

Geralmente vai se utilizar formas matem√°ticas de se utilizar Somat√≥rios, que geralmente s√£o PAs ou PGs.

- √Äs vezes o somat√≥rio √© muito esquisito, que resulta em algo ainda mais esquisito. Exemplo:
  - $\sum^{n}_{i = 0} = \frac{1}{i} = \log n$
  - Mas nesses casos ele geralmente informa que esses "passes de m√°gica" ser√£o utilizados nas provas.

Recurs√£o ser√° muito utilizado. Mesmo algoritmos n√£o recursivos ele tende a escrev√™-las de forma recursiva. Ent√£o, teremos que analisar bem cuidadosamente a complexidade de algoritmos recursivos.

Veremos dois m√©todos para a an√°lise de algoritmos recursivos.

Muitos dos resultados ele tentar√° provar matematicamente que algumas an√°lises est√£o corretas.

Faremos algumas demonstra√ß√µes na disciplina, especialmente nos m√≥dulos 3 e 4, principalmente no 4.

Um dos principais √© prova por indu√ß√£o. Ele tentar√° j√° utilizar algumas provas por indu√ß√£o, especialmente as provas que envolvem grafos na segunda parte da disciplina.

Na primeira parte √© mais conta.

Ele vai tentar n√£o exigir provas matem√°ticas nas avalia√ß√µes, mas geralmente tem na lista. Mesmo que n√£o precise demonstrar, geralmente √© √∫til que se saiba como que acontece para ficar mais f√°cil de entender certas coisas.

Geralmente os alunos tem mais dificuldade nos algoritmos recursivos.

A disciplina ser√° muito corrida √© o tempo da disciplina √© muito curto. Raramente ele demorar√° mais do que uma aula por assunto.

Raramente eles voltar√£o nos assuntos das aulas anteriores.

Se perder alguma aula (Por favor n√£o fa√ßa isso). √â a pior coisa que voc√™ pode fazer nessa disciplina.

Os m√≥dulos geralmente s√£o bem desconexos. Mas num mesmo m√≥dulo, se perder algo, dificilmente vai conseguir recuperar essa informa√ß√£o. Se perdeu algo, vai ter que refazer todas as aulas perdidas antes das aulas posteriores. No primeiro m√≥dulo ainda d√° pra faltar algumas, mas nas pr√≥ximas... üíÄ

Quem n√£o tem acesso ao Moodle, tenha o mais r√°pido poss√≠vel.

Sexta j√° deve ter todos os materiais l√°.

Existe a chance de que mude de sala. E se avisar, ser√° pelo moodle.

### D√∫vidas dos alunos

- Tem monitor?
  - Ele tem X% de certeza que sim, mas ainda n√£o temos. At√© o come√ßo de outubro devem saber quem √©. Geralmente ser√£o na sexta que √© quando estamos mais livres. Ele recomenda fortemente que venhamos nas monitorias. Ele gosta de postar uma lista por semana. √Ä priori elas n√£o valem ponto.
- Enquanto n√£o tem monitor, com quem tirar d√∫vidas?
  - O M√°rcio geralmente tem as manh√£s livres, depois das 8h30 na sala dele 4322 no anexo do DCC. Normalmente √© s√≥ chegar l√° e bater. Sexta ele geralmente t√° aqui o dia todo. Se for algo que demore mais, pode mandar e-mail.
- Vai ter alguma aula de pr√©-PAA ou vai direto na mat√©ria?
  - Ele vai direto na mat√©ria, at√© porque a mat√©ria √© muito extensa.
- Tem v√≠deo-aulas gravadas?
  - Acha que sim, provavelmente o Gabriel Coutinho tem.
- As datas das provas do cronograma est√£o definidas a serem nesses dias mesmo?
  - Sim. Dificilmente mudar√£o a n√£o ser que aconte√ßa algo mt at√≠pico (pandemia/greve). Se acontecer algo com as aulas, ainda d√° pra repor em outros hor√°rios, mas prova √© pouco prov√°vel que se altere.
- A substitutiva [funciona como]?
  - Se voc√™ perder uma avalia√ß√£o, ele sempre abre uma substitutiva para cobrir uma que vc perdeu. Ele costuma deixar que vc fa√ßa a substitutiva mesmo que tenha feito as provas. E a nota da substitutiva sobrescreve a que voc√™ j√° fez, independente de ser maior ou menor.
  - A substitutiva ocorre no s√°bado. Sempre s√°bado de manh√£, normalmente √†s 9h. As provas geralmente s√£o nos hor√°rios de aula. A Olga geralmente prefere fazer as provas no s√°bado tamb√©m.
- O conte√∫do da substitutiva √© qual?
  - O conte√∫do vai ser de acordo com a prova que voc√™ quer substituir.
- Alguma pergunta que n√£o vi
  - Ele vai dizer quais v√£o ser os cap√≠tulos que ele dar√° em cada aula. O livro √© da terceira vers√£o.
- Qual a diferen√ßa entre "PG2" e "PG1_PG2 - Metaturma"?
  - Nenhuma. S√£o duas turmas diferente acontecendo no mesmo hor√°rio, com o mesmo professor, na mesma sala. A Meta-turma √© para reencaminhar os conte√∫dos para as turmas menores.
- E onde enviaremos as atividades?
  - Na Metaturma.
- Qual o cap√≠tulo da aula de segunda?
  - Se n√£o se engana, os cap√≠tulos 2 e 3. E veja tamb√©m os conte√∫dos de pr√©-PAA.

## Aula 2 - 30/09/2024 - [13h08, 14h40]

### Slide: Complexidade de Algoritmos

- Algoritmos no geral ser√£o considerados como fun√ß√µes $f(n)$ que transformam conjunto de entrada em conjunto de sa√≠da.
- Para descrever os algoritmos, ser√£o utilizados pseudoc√≥digos de forma imperativa com estruturas usuais de controle de fluxo.
- atribui√ß√£o como setas e iguais como compara√ß√£o
- Estruturas de dados simples.
- Considera-se mem√≥ria infinita sem se preocupar com a atribui√ß√£o.

D√∫vida 1: Exemplo algoritmo 1: o i=1 seria uma compara√ß√£o ou atribui√ß√£o?

- D√∫vida 2: Exemplo algoritmo 2: Por que a sa√≠da t√° como "?"?
  - Resposta: Para pensarmos sobre o que o algoritmo t√° fazendo, sem dar a resposta de cara.

- Todos os algoritmos ignoram completamente quaisquer dos cornercases que poderiam dar errado: overflow, aloca√ß√£o de mem√≥ria, typechecking, etc.
- O problema do m√≥dulo 1 √© analisar qu√£o bons ou ruins s√£o os algoritmos. Suponho eu que seja a nota√ß√£o de Big-O.
- A complexidade de um algoritmo √© uma fun√ß√£o que descreve o n√∫mero de opera√ß√µes elementares que o algoritmo executa em fun√ß√£o do tamanho da entrada.
- "Custos"
  - Se = Escolha, subconjunto. [Considero que seja algo do tipo um "ou", ou uma multiplica√ß√£o entre as possibilidades.]
  - Para e enquanto: Somat√≥rio
  - Atribui√ß√£o: tempo unit√°rio
  - Matem√°tica e regras: tempo unit√°rio  (a depender da complexidade das regras)
  - Estruturas de dados: Tempo de cada opera√ß√£o.
- O la√ßo tem custo de "2" porque incrementa e compara se chegou na condi√ß√£o.
- No caso do Algoritmo 1, a Fun√ß√£o seria: $F_1(x, n) = 1 + \sum_{i=1}^{n} (2 + 3) = 1 + \sum_{i=1}^{n} (5) = 1 + 5n$.
- No caso do Algoritmo 2, a Fun√ß√£o seria: $F_2(x, n) = 2 + \sum_{i=2}^{n} (1 [checagem do loop] +2 [compara√ß√£o condicional + indexa√ß√£o] +1 [somat√≥rio do iterador]) + \sum_{i=2; se x[i] for par}^{n} (1) [CASOS EM QUE OCORRE A OPERA√á√ÉO *SE*] = 2 + (n-1)*4 [N-1 porque come√ßou i pelo valor 2] + \sum_{i=2; se x[i] for par}^{n} (1)$.
  - Poderia tamb√©m utilizar algo como $\sum_{i=2; se x[i] for par}^{n} (1) = (x[i]\%2)*1$
- Exemplo Algoritmo 3:
  - 1: n*m: preencher a matriz Z NxM
  - 2: compara√ß√£o e incremento do loop i
  - 2: compara√ß√£o e incremento do loop j
  - 8: 2: indexa√ß√£o $z[i][j]$, 2: indexa√ß√£o $x[i][j]$, 2: indexa√ß√£o $y[i][j]$, 1: soma x e y, 1: atribui√ß√£o em $z[i][j]$
  - $F_3(x, y, n, m) = n*m + \sum_{i=1}^{n} (2 + \sum_{j=1}^{m} (2+8)) = n*m + \sum_{i=1}^{n} (2 + 10m) = n*m + 2n + 10nm = 11nm + 2n$

- Inst√¢ncia: conjunto de dados de entrada de um algoritmo: $I$
- Tamanho de uma inst√¢ncia: tamanho em bits da entrada: $I_n$
- Complexidade de um algoritmo: √© a fun√ß√£o que leva o tamanho da inst√¢ncia em...

- Complexidade de pior caso: o maior n√∫mero de passos para uma inst√¢ncia de tamanho $n$.
  - $T(n) = \max_{x \in I_n} F(n, x)$
- Complexidade de melhor caso: o menor n√∫mero de passos para uma inst√¢ncia de tamanho $n$.
  - $T(n) = \min_{x \in I_n} F(n, x)$

D√∫vida: Existe um c√°lculo estat√≠stico de qu√£o prov√°veis de ocorrer s√£o os melhores e maiores casos?
Resposta: Pelo que eu entendi, at√© d√°, s√≥ que √© bem dif√≠cil calcular

- Complexidade de m√©dio caso: o n√∫mero esperado de passos para uma inst√¢ncia de tamanho $n$.
  - $T(n) = \sum_{x \in I_n} P(x)F(n, x)$
  - $P(x)$ √© a probabilidade de ocorrer a inst√¢ncia $x$.
    - "Mas como calcular a probabilidade de uma inst√¢ncia?" "N√£o √© t√£o f√°cil assim"
- Ele sempre considerar√° "complexidade" como sendo "complexidade de pior caso".

- Algoritmo 1:
  - Melhor: [...] 1+5n
  - Pior:  [...] 1+5n
  - M√©dio:  [...] 1+5n
    - Entendi +- como que o F(x, n) foi pra fora do somat√≥rio.
- Algoritmo 2:
  - Melhor: todos elementos s√£o √≠mpares [...] 5n - 4
  - Pior: todos elementos s√£o pares [...] 7n-6
  - M√©dio:  [...] M√≥ trampo. Favor ignorar üòÑüëç

- An√°lise Assint√≥tica
  - O objetivo √© analisar o comportamento de uma fun√ß√£o quando $n$ tende ao infinito.

- D√∫vida: Por que eu compararia n=infinito do pior com o n=infinito do melhor?
- Resposta: Porque no caso, o que a gente t√° comparando √© a melhor e pior distribui√ß√£o dos valores para uma mesma quantidade de elementos. Ent√£o, a gente t√° comparando o melhor caso de uma quantidade de elementos com o pior caso de uma quantidade de elementos.

- Simbolos:
  - $O$
  - $o$
  - $\Theta$
  - $\Omega$

- f = G(g). Essa parte ficou Muito confusa.
- f = O(g) Existem $n_0$ e $c$ tal que: $f(n) \leq c*g(n)$ para todo $n \geq n_0$
  - Entende-se o $c$ como sendo uma forma de chutar o valor de $g$ para cima. E o $n_0$ indica o momento em que $f$ come√ßa a ser menor que $g$.

- Geralmente e procura o menor limite superior assint√≥tico, mas usar outros maiores tamb√©m √© v√°lido. (Menos na prova)
  - $N^k + N^{k-1} \dots + N + 1 = O(N^k)$

Alguns exerc√≠cios ser√£o mostrar valores $C$ e $N_o$ que satisfa√ßam a equa√ß√£o e provem o limite superior.

Geralmente o que ele vai pedir √© encontrar o O() de uma fun√ß√£o.

## Estudar

- Material de Pr√©-PAA
- Heap
- Transforma√ß√£o de logaritmo

## D√∫vidas

$O(n!)$ isn't equivalent to $O(n^n)$. It is asymptotically less than $O(n^n)$.

$O(\log(n!))$ is equal to $O(n \log(n))$. Here is one way to prove that:

Note that by using the log rule $\log(mn) = \log(m) + \log(n)$ we can see that:

$\log(n!) = \log(n*(n-1)*...2*1) = \log(n) + \log(n-1) + ... \log(2) + \log(1)$

Proof that $O(\log(n!)) \subseteq O(n \log(n))$:

$\log(n!) = \log(n) + \log(n-1) + ... \log(2) + \log(1)$

Which is less than:

$\log(n) + \log(n) + \log(n) + \log(n) + ... + \log(n) = n*\log(n)$

So $O(\log(n!))$ is a subset of $O(n \log(n))$

Proof that $O(n \log(n)) \subseteq O(\log(n!))$:

$\log(n!) = \log(n) + \log(n-1) + \dots \log(2) + \log(1)$

Which is greater than the left half of that expression with all $(n-x)$ replaced by $n/2$:

$\log(n/2) + \log(n/2) + ... + \log(n/2) = floor(n/2)*\log(floor(n/2)) \in O(n \log(n))$

So $O(n \log(n))$ is a subset of O(\log(n!))$.

Since $O(n \log(n)) \subseteq O(\log(n!)) \subseteq O(n \log(n))$, they are equivalent big-Oh classes.
